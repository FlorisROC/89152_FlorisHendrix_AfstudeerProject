//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

#define MAX_STRING_LEN    80
#define LF 	          		16#0A		// LF	- LineFeed
#define CR 		          	16#0D		// CR	- Caridge return
#define SEPARATOR  	    	';'
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "FileBaseCsv"
	Revision           = "0.12"
	GUID               = "{5286AFEE-8EE9-4FE1-9CA1-D5BDCBDD545C}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(312,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{2F0E2FE2-20A5-42B1-A7D3-84A935A1AB61}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="FileOS" Required="false" Internal="false"/>
		<Client Name="KernelOS" Required="false" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="ST" Author="PvE"/>
		<Dokumentation Revision="0.12" Date="2016-07-19" Author="PvE" Company="ST" Description="functions BuildFileName and WriteFile added "/>
		<Dokumentation Revision="0.11" Date="2011-07-19" Author="PvE" Company="ST"/>
	</RevDoku>
</Class>
*)
FileBaseCsv : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
	FileOS 	: CltChCmd__FileSys;
	KernelOS 	: CltChCmd__OSKernel;
  //Variables:
		TxtLine : ARRAY [0..MAX_STRING_LEN] OF CHAR;

		SysDate 	: SYSDATE;
		SysTime 	: SYSTIME;
  //Functions:
	
	FUNCTION GLOBAL NewDir
		VAR_INPUT
			dirname 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL OpenFile
		VAR_INPUT
			filename 	: ^CHAR;
			attrib 	: UDINT;
		END_VAR
		VAR_OUTPUT
			handle 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL CloseFile
		VAR_INPUT
			handle 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL LoadFile
		VAR_INPUT
			fileInfo 	: ^strFileInfo;
		END_VAR;
	
	FUNCTION GLOBAL SaveFile
		VAR_INPUT
			fileInfo 	: ^strFileInfo;
		END_VAR;
	
	FUNCTION GLOBAL DeleteFile
		VAR_INPUT
			filename 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL CopyFile
		VAR_INPUT
			src 	: ^CHAR;
			dest 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetFileLength
		VAR_INPUT
			handle 	: DINT;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL BuildValue2Ascii
		VAR_INPUT
			value 	: DINT;
			dest 	: ^CHAR;
			offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL BuildSeparator
		VAR_INPUT
			dest 	: ^CHAR;
			offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL BuildDate
		VAR_INPUT
			mode 	: DINT;
			src 	: SYSDATE;
			dest 	: ^CHAR;
			offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL BuildSysDate
		VAR_INPUT
			mode 	: DINT;
			dest 	: ^CHAR;
			offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL BuildTime
		VAR_INPUT
			mode 	: DINT;
			src 	: SYSTIME;
			dest 	: ^CHAR;
			offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL BuildSysTime
		VAR_INPUT
			mode 	: DINT;
			dest 	: ^CHAR;
			offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL BuildEol
		VAR_INPUT
			dest 	: ^CHAR;
			offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL WriteLine
		VAR_INPUT
			handle 	: DINT;
			src 	: ^CHAR;
			len 	: DINT;
		END_VAR
		VAR_OUTPUT
			size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL Read2Separator
		VAR_INPUT
			src 	: ^CHAR;
			sOffset 	: DINT;
			dest 	: ^CHAR;
			dOffset 	: DINT;
		END_VAR
		VAR_OUTPUT
			size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ConvAscii2Value
		VAR_INPUT
			src 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			value 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL Read2Nil
		VAR_INPUT
			src 	: ^CHAR;
			sOffset 	: DINT;
			dest 	: ^CHAR;
			dOffset 	: DINT;
		END_VAR
		VAR_OUTPUT
			size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ReadLine
		VAR_INPUT
			handle 	: DINT;
			dest 	: ^CHAR;
			offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL BuildFileName
		VAR_INPUT
			path 	: ^CHAR;
			name 	: ^CHAR;
			ext 	: ^CHAR;
			dest 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL WriteFile
		VAR_INPUT
			name 	: ^CHAR;
			ext 	: ^CHAR;
			path 	: ^CHAR;
			pSrc 	: ^DINT;
			sizeDint 	: DINT;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd _OSKernel


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB FileBaseCsv::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_FILEBASECSV
0$UINT, 12$UINT, (SIZEOF(::FileBaseCsv))$UINT, 
1$UINT, 2$UINT, 0$UINT, 
TO_UDINT(3416595442), "FileBaseCsv", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::FileBaseCsv.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
(::FileBaseCsv.FileOS.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(523274688), "FileOS", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::FileBaseCsv.KernelOS.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(4054490103), "KernelOS", TO_UDINT(3045737964), "_OSKernel", 0$UINT, 5$UINT, 
END_FUNCTION


#define USER_CNT_FileBaseCsv 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_FileBaseCsv] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION FileBaseCsv::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION GLOBAL FileBaseCsv::NewDir
	VAR_INPUT
		dirname 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR
  
  result:= FileOS.CreateDirectory(dirname:= dirname);
  
END_FUNCTION  //FileBaseCsv::NewDir


FUNCTION GLOBAL FileBaseCsv::OpenFile
	VAR_INPUT
		filename 	: ^CHAR;
		attrib 	: UDINT;
	END_VAR
	VAR_OUTPUT
		handle 	: DINT;
	END_VAR
  
  handle:= FileOS.FileOpen(filename:= filename, attributes:= attrib);
  
END_FUNCTION  //FileBaseCsv::OpenFile


FUNCTION GLOBAL FileBaseCsv::CloseFile
	VAR_INPUT
		handle 	: DINT;
	END_VAR
  
  FileOS.FileClose(handle:= handle);
  
END_FUNCTION  //FileBaseCsv::CloseFile


FUNCTION GLOBAL FileBaseCsv::LoadFile
	VAR_INPUT
		fileInfo 	: ^strFileInfo;
	END_VAR
  VAR
  	nrLines   : DINT;
    i         : DINT;
    src       : ^DINT;
  END_VAR
  
  nrLines:= fileInfo^.DataSize / sizeof(DINT);
  src    := fileInfo^.pData;
	//
	if nrLines > 0 then
 
		for i:= 1 to nrLines do
      //read line from file
      ReadLine(handle:= fileInfo^.Handle, dest:= #TxtLine[0], offset:= 0);
                   
			if TxtLine[0] <> nil then
				//value
        if Read2Separator(src:= #TxtLine[0], sOffset:= 0, dest:= #TxtLine[0], dOffset:= 0) >= 0 then
          src^:= ConvAscii2Value(src:= #TxtLine[0]);
        end_if;
        
        //increase data pointer
				src+= sizeof(DINT);
			else
				i:= nrLines;
	      TRACE("FileBaseCsv::LoadFile - unexpected end of file");
			end_if;
      
		end_for;
    
	end_if;  
END_FUNCTION  //FileBaseCsv::LoadFile


FUNCTION GLOBAL FileBaseCsv::SaveFile
	VAR_INPUT
		fileInfo : ^strFileInfo;
	END_VAR
  VAR
  	nrLines  : DINT;
    i        : DINT;
    src      : ^DINT;
    offset   : DINT;
  END_VAR

  nrLines:= fileInfo^.DataSize / sizeof(DINT);
  src    := fileInfo^.pData;
  
  if nrLines > 0 then
	  //build parameter lines
	  for i := 1 to nrLines do
  		
	  	//value
      offset:= BuildValue2Ascii(value:= src^, dest:= #TxtLine[0], offset:= 0);
      
      //end of line
  		offset+= BuildEol(dest:= #TxtLine[0], offset:= offset);
      
      //write line   
      WriteLine(handle:= fileInfo^.Handle, src:= #TxtLine[0], len:= offset);
      
      //increase data pointer
      src+= sizeof(DINT);
	  end_for;
  end_if; 
  
END_FUNCTION  //FileBaseCsv::SaveFile


FUNCTION GLOBAL FileBaseCsv::DeleteFile
	VAR_INPUT
		filename 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR
  
  result:= FileOS.FileDelete(filename:= filename);
  
END_FUNCTION  //FileBaseCsv::DeleteFile


FUNCTION GLOBAL FileBaseCsv::CopyFile
	VAR_INPUT
		src 	: ^CHAR;
		dest 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR

  result:= FileOS.FileCopy(pSource:= src, pDest:= dest, udOption:= 0);

END_FUNCTION  //FileBaseCsv::CopyFile


FUNCTION GLOBAL FileBaseCsv::GetFileLength
	VAR_INPUT
		handle 	: DINT;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR
  
  result:= FileOS.FileLength(handle:= handle);
  
END_FUNCTION  //FileBaseCsv::GetFileLength

// value  : 
// dest   : pointer to dest string
// offset : offset in dest string
// size   : string size of converted value or 0 in case of error
FUNCTION GLOBAL FileBaseCsv::BuildValue2Ascii
	VAR_INPUT
		value 	: DINT;
		dest 	  : ^CHAR;
		offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		size 	  : DINT;
	END_VAR
  VAR
  	i       : DINT;
    j       : DINT;
    tmp     : ARRAY[0..11] of CHAR;
  END_VAR

  size:= -1;
  //test for sign
  if value < 0 then
	  if offset < MAX_STRING_LEN then
		  (dest + offset)^	:= '-';
		  offset+= 1;
		  size	+= 1;
		  value	*= -1;
    end_if;
  end_if;
  
  //convert to ascii
  i	     := 0;
  j      := 10;
  tmp[11]:= nil$char;
  repeat
		tmp[j]:= to_usint(value mod 10) + '0';
		value	/= 10;
		i		  += 1;
		j		  -= 1;
  until value = 0 end_repeat;

  //write to dest
  if offset + i <= MAX_STRING_LEN then
  	for j:= 11 - i to 11 do
	  	(dest + offset)^	:= tmp[j];
		  offset+= 1;
  		size	+= 1;
	  end_for;
  else
	  size:= 0;
  end_if;
  
END_FUNCTION  //FileBaseCsv::BuildValue2Ascii


//dest  : pointer to begin of string of size MAX_STRING_LEN
//offset: offset in dest
//size  : size of separator - 0 = not build
FUNCTION GLOBAL FileBaseCsv::BuildSeparator
	VAR_INPUT
		dest 	: ^CHAR;
		offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		size 	: DINT;
	END_VAR
  
  size:= 0;
  if offset < MAX_STRING_LEN then
    (dest + offset)^:= SEPARATOR;
    offset+= 1;
	  (dest + offset)^:= nil$CHAR;
	  size:= 1;
  end_if;
  
END_FUNCTION  //FileBaseCsv::BuildSeparator


FUNCTION GLOBAL FileBaseCsv::BuildDate
	VAR_INPUT
		mode 	: DINT;
		src 	: SYSDATE;
		dest 	: ^CHAR;
		offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		size 	: DINT;
	END_VAR
  
  size:= 0;
  
  case mode of
    1:		//dd-mm-yyyy
    	if (offset + 10) <= MAX_STRING_LEN then
  	  	if SysDate.wDay < 10 then
	  	  	(dest + offset)^:= '0';
	  		  offset          += 1;
    		end_if;
        offset+= BuildValue2Ascii(value:= src.wDay, dest:= dest, offset:= offset);
        (dest + offset)^:= '-';
	    	offset          += 1;
	  	  if src.wMonth < 10 then
          (dest + offset)^:= '0';
  	  		offset          += 1;
	    	end_if;
        offset+= BuildValue2Ascii(value:= src.wMonth, dest:= dest, offset:= offset);
        (dest + offset)^:= '-';
	    	offset          += 1;
        offset+= BuildValue2Ascii(value:= src.wYear, dest:= dest, offset:= offset);
    		(dest + offset)^:= nil$CHAR;
        size            := 10;
	    end_if;

  else	//yyyy-mm-dd
    if (offset + 10) <= MAX_STRING_LEN then
      offset+= BuildValue2Ascii(value:= src.wYear, dest:= dest, offset:= offset);
      (dest + offset)^:= '-';
	    offset          += 1;
      if src.wMonth < 10 then
        (dest + offset)^:= '0';
     		offset          += 1;
	   	end_if;
      offset+= BuildValue2Ascii(value:= src.wMonth, dest:= dest, offset:= offset);
      (dest + offset)^:= '-';
	    offset          += 1;
  	  if SysDate.wDay < 10 then
	  	  (dest + offset)^:= '0';
	  		offset          += 1;
    	end_if;
      offset+= BuildValue2Ascii(value:= src.wDay, dest:= dest, offset:= offset); 
    	(dest + offset)^:= nil$CHAR;
      size            := 10;
	  end_if;
    
  end_case;

END_FUNCTION  //FileBaseCsv::BuildDate

//mode  : 
//dest  : pointer to begin of string of size MAX_STRING_LEN
//offset: offset in dest
//size  : size of date - 0 = not build
FUNCTION GLOBAL FileBaseCsv::BuildSysDate
	VAR_INPUT
		mode 	  : DINT;
		dest 	  : ^CHAR;
		offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		size   	: DINT;
	END_VAR
  
  KernelOS.GetSystemDate(datestruct:= #SysDate);
  size:= BuildDate(mode:= mode, src:= SysDate, dest:= dest, offset:= offset);

END_FUNCTION  //FileBaseCsv::BuildSysDate


FUNCTION GLOBAL FileBaseCsv::BuildTime
	VAR_INPUT
		mode 	: DINT;
		src 	: SYSTIME;
		dest 	: ^CHAR;
		offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		size 	: DINT;
	END_VAR
  VAR
  	AmPm  : BOOL;
  END_VAR

  size:= 0;

  case mode of
    1:		//hh:mm:ss xm in 12 hour mode.
    	if (offset + 11) <= MAX_STRING_LEN then
    		if src.wHour < 12 then
		    	AmPm:= false;
    		else
		    	AmPm:= true;
    		end_if;
		    if src.wHour >= 13 then
    			src.wHour-= 12;
		    end_if;
		    // hour
		    if src.wHour < 10 then
			    (dest + offset)^:= '0';
			    offset        	+= 1;
		    end_if;
        offset+= BuildValue2Ascii(value:= src.wHour, dest:= dest, offset:= offset);
		    (dest + offset)^:= ':';
		    offset        	+= 1;
		    // Minute
		    if src.wMinute < 10 then
			    (dest + offset)^:= '0';
			    offset        	+= 1;
		    end_if;
        offset+= BuildValue2Ascii(value:= src.wMinute, dest:= dest, offset:= offset);
		    (dest + offset)^:= ':';
		    offset        	+= 1;
		    // Seconds
		    if src.wSecond < 10 then
			    (dest + offset)^:= '0';
			    offset        	+= 1;
		    end_if;
        offset+= BuildValue2Ascii(value:= src.wSecond, dest:= dest, offset:= offset);
		    (dest + offset)^:= ' ';
		    offset	        += 1;
		    // am pm
		    if AmPm = false then
			    (dest + offset)^:= 'a';
			    offset          += 1;
		    else
			    (dest + offset)^:= 'p';
			    offset          += 1;
		    end_if;
        (dest + offset)^:= 'm';
        offset          += 1;
		    (dest + offset)^:= nil$CHAR;
        size:= 11;
    	end_if;

  else	//hh:mm:ss in 24 hour format
  	if (offset + 8) <= MAX_STRING_LEN then
  		if src.wHour < 10 then
	  		(dest + offset)^:= '0';
		  	offset        	+= 1;
		  end_if;
      offset+= BuildValue2Ascii(value:= src.wHour, dest:= dest, offset:= offset);
      (dest + offset)^:= ':';
		  offset          += 1;
		  if src.wMinute < 10 then
			  (dest + offset)^:= '0';
			  offset        	+= 1;
		  end_if;
      offset+= BuildValue2Ascii(value:= src.wMinute, dest:= dest, offset:= offset);
		  (dest + offset)^:= ':';
		  offset        	+= 1;
		  if src.wSecond < 10 then
			  (dest + offset)^:= '0';
			  offset        	+= 1;
		  end_if;
      offset+= BuildValue2Ascii(value:= src.wSecond, dest:= dest, offset:= offset);
		  (dest + offset)^:= nil$CHAR;
      size:= 8;
	  end_if;
  end_case;
  
END_FUNCTION  //FileBaseCsv::BuildTime


FUNCTION GLOBAL FileBaseCsv::BuildSysTime
	VAR_INPUT
		mode   	: DINT;
		dest 	  : ^CHAR;
		offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		size 	  : DINT;
	END_VAR
  
  KernelOS.GetSystemTime(timestruct:= #SysTime);
  size:= BuildTime(mode:= mode, src:= SysTime, dest:= dest, offset:= offset);
  
END_FUNCTION  //FileBaseCsv::BuildSysTime


FUNCTION GLOBAL FileBaseCsv::BuildEol
	VAR_INPUT
		dest 	: ^CHAR;
		offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		size 	: DINT;
	END_VAR
  
  size	:= 0;
  if (offset + 2) <= MAX_STRING_LEN then
  	(dest + offset)^:= CR;
	  offset	+= 1;
  	(dest + offset)^:= LF;
	  offset	+= 1;
	  (dest + offset)^:= nil$char;
	  size	:= 2;
  end_if;
  
END_FUNCTION  //FileBaseCsv::BuildEol


FUNCTION GLOBAL FileBaseCsv::WriteLine
	VAR_INPUT
		handle 	: DINT;
		src 	  : ^CHAR;
		len 	  : DINT;
	END_VAR
	VAR_OUTPUT
		size 	  : DINT;
	END_VAR
  
  size:= 0;
  if handle > 0 then
    size:= FileOS.FileWrite(handle:= handle, buffer:= src, length:= to_udint(len));
	  if size <> len then
		  TRACE( "FileBaseCsv::WriteLine - string not (completely) written");
	  end_If;
  else
	  TRACE( "FileBaseCsv::WriteLine - no file handle");
  end_if;
  
END_FUNCTION  //FileBaseCsv::WriteLine

//src    : pointer to source string
//sOffset: offset in source string
//dest   : pointer to destination string
//dOffset: offset in dest string
FUNCTION GLOBAL FileBaseCsv::Read2Separator
	VAR_INPUT
		src 	: ^CHAR;
		sOffset 	: DINT;
		dest 	: ^CHAR;
		dOffset 	: DINT;
	END_VAR
	VAR_OUTPUT
		size 	: DINT;
	END_VAR
  VAR
	  i		    : DINT;
  END_VAR
  
  size:= 0;
  src += sOffset;
  dest+= dOffset;
  for i:= 0 to (MAX_STRING_LEN - sOffset) do    //src+offset to src+offset+max-offset
    if dOffset <= MAX_STRING_LEN then
      case src^ of
        0, CR, LF, SEPARATOR:
          dest^:= nil$CHAR;
          i    := MAX_STRING_LEN - sOffset;
      else
        if i < (MAX_STRING_LEN - sOffset) then
          dest^  := src^;  
          size   += 1;
          src    += 1;
          dest   += 1;
          dOffset+= 1;
        else
          //string without separator
          dest^:= nil$CHAR;
          size := 0;
          TRACE("FileBaseCsv::Read2Separator - string without separator");
        end_if;
      end_case;
    else
      dest^:= nil$CHAR;
      size := 0;
      i    := MAX_STRING_LEN - sOffset;
      TRACE("FileBaseCsv::Read2Separator - end destination string");
    end_if;
  end_for;
  
END_FUNCTION  //FileBaseCsv::Read2Separator

//src   : pointer to ascii string   [-] (max 10 nrs) nil
//value : converted string
FUNCTION GLOBAL FileBaseCsv::ConvAscii2Value
	VAR_INPUT
		src 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		value 	: DINT;
	END_VAR
  VAR
  	i    : DINT;
    sign : DINT;
  END_VAR

  sign := 1;
  value:= 0;
  
  for i:= 0 to 11 do
	  case src^ of
	    0:
  		  i:= 11;
	    '-':
  		  sign:= -1;
	    '0'..'9':
  		  value*= 10;
	  	  value+= to_dint(src^ - '0');
  	end_case;
	  src+= 1;
  end_for;
  
  value*= sign;
  
END_FUNCTION  //FileBaseCsv::ConvAscii2Value

//src   : pointer to source string
//dest  : pointer to destination string
//offset: offset in destination string
FUNCTION GLOBAL FileBaseCsv::Read2Nil
	VAR_INPUT
		src 	  : ^CHAR;
		sOffset : DINT;
		dest    : ^CHAR;
		dOffset : DINT;
	END_VAR
	VAR_OUTPUT
		size  	: DINT;
	END_VAR
  VAR
  	i       : DINT;
  END_VAR

  size:= 0;
  src += sOffset;
  dest+= dOffset;
  for i:= 0 to (MAX_STRING_LEN - sOffset) do    //src+offset to src+offset+max-offset
    if dOffset <= MAX_STRING_LEN then
      case src^ of
        0:
          dest^:= nil$CHAR;
          i    := MAX_STRING_LEN - sOffset;
      else
        if i < (MAX_STRING_LEN - sOffset) then
          dest^  := src^;  
          size   += 1;
          src    += 1;
          dest   += 1;
          dOffset+= 1;
        else
          //string without separator
          dest^:= nil$CHAR;
          size := 0;
          TRACE("FileBaseCsv::Read2Nil - string without separator");
        end_if;
      end_case;
    else
      dest^:= nil$CHAR;
      size := 0;
      i    := MAX_STRING_LEN - sOffset;
      TRACE("FileBaseCsv::Read2Nil - end destination string");
    end_if;
  end_for;
  
END_FUNCTION  //FileBaseCsv::Read2Nil


FUNCTION GLOBAL FileBaseCsv::ReadLine
	VAR_INPUT
		handle 	: DINT;
		dest 	: ^CHAR;
		offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		size 	: DINT;
	END_VAR
  VAR
    endPtr    : ^CHAR;
  	readBytes : UDINT;
  END_VAR

  size:= 0;
  if handle > 0 then
  	endPtr:= dest	+ MAX_STRING_LEN - 1;
	  dest+= (offset - 1);
	  repeat
		  dest+= 1;
		  readBytes:= FileOS.FileRead(handle:= handle, buffer:= dest, length:= 1);
		  if readBytes > 0 then
			  size+= 1; 
			  if dest^= CR then	// Skip CR
				  dest-= 1;
  				size-= 1;
	  		end_if;
		  else
        size+= 1;
			  dest^:= nil$CHAR;
        TRACE("FileBaseCsv::ReadLine - read error");
		  end_if;
	  until (dest^ = nil$CHAR) | (dest^ = LF) | (dest	>= endPtr) end_repeat;
	  dest^:= nil$CHAR;
	  size -= 1;
  else
	  TRACE( "FileBaseCsv::ReadLine - no handle");
  end_if;

END_FUNCTION  //FileBaseCsv::ReadLine


FUNCTION GLOBAL FileBaseCsv::BuildFileName
	VAR_INPUT
		path 	: ^CHAR;
		name 	: ^CHAR;
		ext 	: ^CHAR;
		dest 	: ^CHAR;
	END_VAR
  VAR
    offset  : DINT;
  END_VAR
  
  offset:= Read2Nil(src:= path, sOffset:= 0, dest:= dest, dOffset:= 0);
  offset+= Read2Nil(src:= name, sOffset:= 0, dest:= dest, dOffset:= offset);
           Read2Nil(src:= ext , sOffset:= 0, dest:= dest, dOffset:= offset);
  
END_FUNCTION  //FileBaseCsv::BuildFileName


FUNCTION GLOBAL FileBaseCsv::WriteFile
	VAR_INPUT
		name 	: ^CHAR;
		ext 	: ^CHAR;
		path 	: ^CHAR;
		pSrc 	: ^DINT;
		sizeDint 	: DINT;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR
  VAR
    offset : DINT;
  	handle : DINT;
    i      : DINT;
  END_VAR
  
  offset:= Read2Nil(src:= path, sOffset:= 0, dest:= #TxtLine[0], dOffset:= 0);
  offset+= Read2Nil(src:= name, sOffset:= 0, dest:= #TxtLine[0], dOffset:= offset);
           Read2Nil(src:= ext , sOffset:= 0, dest:= #TxtLine[0], dOffset:= offset);
  
  handle:= OpenFile(filename:= #TxtLine[0], attrib:= ATT_CREATE_ALWAYS);

	if handle > 0 then
    i:= 0;
    repeat
      TxtLine[0]:= nil$CHAR;
		  // value
		  offset:= BuildValue2Ascii(value:= pSrc^, dest:= #TxtLine[0], offset:= 0);
      offset+= BuildEol(dest:= #TxtLine[0], offset:= offset);
      WriteLine(handle:= handle, src:= #TxtLine[0], len:= offset);
      pSrc+= sizeof(DINT);
      i  += 1;
    until i>= sizeDint end_repeat;
 
    CloseFile(handle:= handle);
    
    result:= handle;
	else
		result:= handle;
	end_if;
  
END_FUNCTION  //FileBaseCsv::WriteFile
