//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include <.\lsl_st_mt.h>

(*!
<Class
	Name               = "AlarmOPMode0Para"
	Revision           = "1.6"
	GUID               = "{F1B42DFD-7304-48EA-B5CB-AFFCA064FF7A}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(414,120)"
	Comment            = "Class to handle one alarm, which must be used in comination with the tools-class AlarmBuffer.&#13;&#10;">
	<Channels>
		<Server Name="ClassSvr" WriteProtected="false">
		</Server>
		<Client Name="AlarmInfo" Required="false" Internal="false" DefValue="2#00000000" Comment="Additional informations for the alarm. This information is available in the class AlarmBuffer and can be evaluated by the user by deriving the class.&#13;&#10;&#13;&#10;This information is not available in the visualisation."/>
		<Client Name="AlarmMode" Required="false" Internal="false" DefValue="2#0" Comment="Settings for the Alarm.&#13;&#10;&#13;&#10;Bit0:&#13;&#10;0 .. no deletion of alarm with quit&#13;&#10;1 .. delete alarm with quit&#13;&#10;&#13;&#10;Bit1:&#13;&#10;0 .. an alarm can only be acknowledged once&#13;&#10;1 .. multiple acknowledging is possible"/>
		<Client Name="OPMode" Required="false" Internal="false" DefValue="OPMode_Init" Comment="This client indicates the categorie of the alarm.&#13;&#10;&#13;&#10;In the class AlarmBuffer number of active alarms for the selected categorie is counted. This number can be evaluated by the user by deriving the class AlarmBuffer.&#13;&#10;&#13;&#10;This information is not available in the visualisation."/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\AlarmOPMode0Para\AlarmOPMode0Para.pdf"/>
			<File Path=".\Class\AlarmOPMode0Para\AlarmOPMode0Para_en.pdf"/>
			<File Path=".\lsl_st_mt.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.6" Date="2023-12-05" Author="KaiAnd" Company="Sigmatek" Description="The class was adapted to the extensions of the base class _AlarmX0Para V0.20 via the &quot;Assimilate Overwritten Method&quot;."/>
		<Dokumentation Revision="1.5" Date="2018-02-06" Author="SchMat" Company="Sigmatek" Description="ensure multithreading&#13;&#10;-added mutex &quot;AP_ALARM&quot;&#13;&#10;-changed method ClassSvr::Write()"/>
		<Dokumentation Revision="1.4" Date="2016-11-04" Author="HubChr" Company="Sigmatek" Description="Bugfix: Acknowledging was not successfully forwarded to alarmbuffer."/>
		<Dokumentation Revision="1.3" Date="2016-06-16" Author="ObeChr" Company="Sigmatek" Description="Settings of client OPMode + AlarmInfo are only read in case the alarm gets active. That&apos;s necessary to prevent couting problem in the class AlarmBufferBase."/>
		<Dokumentation Revision="1.2" Date="2016-03-10" Author="HubChr" Company="Sigmatek" Description="Implemented possibility for multiple acknowledging of alarms. (See Client AlarmMode)"/>
		<Dokumentation Revision="1.1" Date="2015-06-09" Author="ObeChr" Company="Sigmatek" Description="Implemented function to delete alarm with quit."/>
		<Dokumentation Revision="1.0" Date="2015-06-01" Author="ObeChr" Company="Sigmatek" Description="First version of class for delivering OPMode and AlarmAction to the class AlarmBuffer."/>
	</RevDoku>
	<Network Name="AlarmOPMode0Para">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{ABEDA7EA-9B2E-4F8C-B5E9-C7C895E9C61C}"
				Class      = "_AlarmX0Para"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="Acknow"/>
					<Client Name="Config" Value="0"/>
					<Client Name="Group"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(734,210),(562,210),"/>
			<Connection Source="_base.Config" Destination="this.Config" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Acknow" Destination="this.Acknow" Vertices="(218,270),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _AlarmX0Para

AlarmOPMode0Para : CLASS
: _AlarmX0Para
  //Servers:
  //Clients:
	OPMode 	: CltCh_t_e_OPMode;
	AlarmInfo 	: CltCh_BDINT;
	AlarmMode 	: CltCh_BDINT;
  //Variables:
		bAcknowConnected 	: DINT;
		eOPMode 	: t_e_OPMode;
		bdAlarmInfo : BDINT
		[
		  1 Bit1,
		  2 Bit2,
		  3 Bit3,
		  4 Bit4,
		  5 Bit5,
		  6 Bit6,
		  7 Bit7,
		  8 Bit8,
		  9 Bit9,
		  10 Bit10,
		  11 Bit11,
		  12 Bit12,
		  13 Bit13,
		  14 Bit14,
		  15 Bit15,
		  16 Bit16,
		  17 Bit17,
		  18 Bit18,
		  19 Bit19,
		  20 Bit20,
		  21 Bit21,
		  22 Bit22,
		  23 Bit23,
		  24 Bit24,
		  25 Bit25,
		  26 Bit26,
		  27 Bit27,
		  28 Bit28,
		  29 Bit29,
		  30 Bit30,
		  31 Bit31,
		  32 Bit32,
		];

  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION AlarmOPMode0Para
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetParaID
		VAR_INPUT
			ppara 	: ^UDINT;			//! <Variable Comment="Pointer to an UDINT array, that is to be filled with the Lasal IDs of the connected numeric parameter servers of the given alarm implementation. &#13;&#10;This is usually done by inserting the pCH data field of the parameter client at the corresponding array location. &#13;&#10;If the numeric value is a constant value, the array location is to be filled with 0." Name="GetParaID.ppara"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;			//! <Variable Comment="Returns the number of numeric parameters provided by the given alarm implementation." Name="GetParaID.retcode"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetParaVal
		VAR_INPUT
			ppara 	: ^DINT;			//! <Variable Comment="Pointer to a DINT array with the size specified by the return value of GetParaID(). &#13;&#10;The array is to be filled with the current numeric parameter values, usually by calling the Read() method of the corresponding parameter client." Name="GetParaVal.ppara"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;			//! <Variable Comment="Returns the number of numeric parameters provided by the given alarm implementation." Name="GetParaVal.retcode"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL QuitAlarm
		VAR_INPUT
			alano 	: UDINT;			//! <Variable Comment="Default value: 0xFFFFFFFF &#13;&#10;The alarm number which should be quit. &#13;&#10;Use the default value if the alarm object represents only one alarm number (GetMultiConfig returns 0 or 1) or a valid alarm number (start + offset) within the configured range if the alarm object represents several alarms (GetMultiConfig returns &gt; 1)" Name="QuitAlarm.alano"/>
		END_VAR;
	
	FUNCTION VIRTUAL QuitAlarmWork;
	
	FUNCTION DoMutex
		VAR_INPUT
			state 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassSvr::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AlarmOPMode0Para::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_ALARMOPMODE0PARA
1$UINT, 6$UINT, (SIZEOF(::AlarmOPMode0Para))$UINT, 
0$UINT, 3$UINT, 0$UINT, 
TO_UDINT(2788710338), "AlarmOPMode0Para", //Class
TO_UDINT(800276940), "_AlarmX0Para", 0$UINT, 20$UINT, //Baseclass
//Servers:
//Clients:
(::AlarmOPMode0Para.OPMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4156859346), "OPMode", 
(::AlarmOPMode0Para.AlarmInfo.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2396232830), "AlarmInfo", 
(::AlarmOPMode0Para.AlarmMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3532712578), "AlarmMode", 
END_FUNCTION


#define USER_CNT_AlarmOPMode0Para 10

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AlarmOPMode0Para] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AlarmOPMode0Para::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _AlarmX0Para::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _AlarmX0Para::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _AlarmX0Para::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AlarmOPMode0Para;
	vmt.CmdTable.Write		:= #ClassSvr::Write();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetParaID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #GetParaVal();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #QuitAlarm();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #QuitAlarmWork();

#pragma warning (default : 74)
	_AlarmX0Para::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _AlarmX0Para::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= AlarmOPMode0Para();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma usingltd _AlarmXBuffer

VAR_PRIVATE
  mt_api      : ^LSL_MT_TYPE;
  alarm_mux   : MT_SEMAHANDLE;
END_VAR

VAR_EXTERNAL
  PV_AlarmBuffer : ^_AlarmXBuffer; // HubChr v1.2 is needed in order to develop own QuitAlarm Method so AlarmMode 2#10 works accordingly.
END_VAR

FUNCTION AlarmOPMode0Para::AlarmOPMode0Para
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

  mt_api    := NIL;
  alarm_mux := NIL;
	ret_code  := C_OK;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL AlarmOPMode0Para::Init

  _AlarmX0Para::Init();

  if (mt_api = NIL) then
    OS_CILGET("LSL_MULTITASK", #mt_api$void);
  end_if;
  if (alarm_mux = NIL) then
    if(mt_api <> NIL) then
      alarm_mux := OS_MT_CreateSemaphore(MTSEMATYPE_MUTEX, 1, 0, "AP_ALARM");
    end_if;
  end_if;

  if _FirstScan = TRUE then
    bAcknowConnected := IsClientConnected(#Acknow);
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL AlarmOPMode0Para::GetParaID
	VAR_INPUT
		ppara 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  // get setting of client OPMode
  //----------------------------------------------------------------
  // => the class AlarmBufferBase checks, 
  //    if the configured OPMode is available
  OPMode := OPMode.Read();
  ppara^ := OPMode$UDINT;
  
  // return number of parameter
  retcode := 1;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmOPMode0Para::GetParaVal
	VAR_INPUT
		ppara 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  // get OPMode of alarm
  //--------------------------------
  ppara^ := eOPMode$DINT;
  
  ppara += sizeof(eOPMode);
  
  // get action of alarm
  //--------------------------------
  ppara^ := bdAlarmInfo$DINT;
  
  // finished
  retcode := 2;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmOPMode0Para::QuitAlarm
	VAR_INPUT
		alano 	: UDINT;
	END_VAR

  // get setting of client alarm
  AlarmMode := AlarmMode.Read();
  
  // no deletion of alarm with quit
  //---------------------------------------------
  if ( AlarmMode AND 2#1 ) = 0 then
  
    // HubChr v1.2 Method of BaseClass is extracted for slightly different behaviour
    QuitAlarmWork();
    
  // delete alarm with quit
  //---------------------------------------------
  else

    // quit Alarm
    QuitAlarmWork(); // HubChr v1.2
    
    // delete alarm
    ClassSvr.Write(0);
  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmOPMode0Para::ClassSvr::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  // HubChr v1.2 now that an alarm can be triggered not only by write with 1 we have to check if it is already active before triggering
   
  if (input = 255) |                    // Alarm is quit
     (ClassSvr = 0) & (input > 0) |     // Alarmstate changes from inactive to active
     (ClassSvr > 0) & (input = 0) then  // Alarmstate changes from active to inactive

    DoMutex(true);

    // Alarm got active
    if input > 0 & input < 255 then

      // read actual setting of OPMode and AlarmInfo
      OPMode    := OPMode.Read();
      AlarmInfo := AlarmInfo.Read();
      
      //save settings
      eOPMode     := OPMode;
      bdAlarmInfo := AlarmInfo;
      
    end_if;

    _AlarmX0Para::ClassSvr.Write(input := input);

    if input <> 255 then // if an alarm is quit by writing 255 on it, we keep the old active state (alarm can be active but quit!)
      ClassSvr := input;
    end_if;

    DoMutex(false);

  end_if;

	result := ClassSvr;

END_FUNCTION


FUNCTION VIRTUAL AlarmOPMode0Para::QuitAlarmWork
  
  
  // HubChr v1.4 Check the flag BEFORE it is set to 1!
  
  if (Acknow = 0) then 
    if(PV_AlarmBuffer <> NIL) then
      Config := Config.Read();
      PV_AlarmBuffer^.ActionAlarm(this$UDINT, Config$UDINT, 0, -1, 0, NIL);
    end_if;
  end_if;
  
  
  // HubChr v1.2 Method QuitAlarm of base class cannot be used anymore because the AlarmMode 2#10 has to be implemented here
  
  if(Acknow = 0) | (AlarmMode AND 2#10) then
    Acknow := 1;
    if(bAcknowConnected <> 0) then // HubChr v1.2 we only check once if the client is connected!
      Acknow.Write(Acknow);
    end_if;
  end_if;    

END_FUNCTION

FUNCTION AlarmOPMode0Para::DoMutex
	VAR_INPUT
		state 	: BOOL;
	END_VAR

  if(alarm_mux <> NIL) then
    if(state = TRUE) then
      OS_MT_Wait(alarm_mux);
    else
      OS_MT_Signal(alarm_mux);
    end_if;
  end_if;

END_FUNCTION
