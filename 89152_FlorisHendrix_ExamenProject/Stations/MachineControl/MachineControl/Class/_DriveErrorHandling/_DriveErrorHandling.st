//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_DriveErrorHandling"
	Revision           = "1.14"
	GUID               = "{14CAB685-9E7C-41EC-B5A3-85D8BDFE3E0A}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\_DriveMngBase\Drive.ico"
	SharedCommandTable = "true"
	Objectsize         = "(374,120)"
	Comment            = "displays the error parameter of the connected Drive">
	<Channels>
		<Server Name="GetErrorInfo" GUID="{BD2949D3-3D1B-41C7-A60A-A3B8A476834F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment=" a write command reads the actual error state of the axis"/>
		<Server Name="I_DERROR" GUID="{5994F1F2-339E-4B70-8B51-942755A4B16E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Para-Nr : 201&#13;&#10;Unit  : [-]&#13;&#10;Description : Internal Drive Errors&#13;&#13;&#10;&#13;&#13;&#10;MDD100,SDD300 - Drives &#13;&#10;=============================================================================================&#13;&#10;Bit   1 SSI_ERROR (not supported by MDD 100)(additional Information to the Host Communication Error in [I-STATUS])&#13;&#10;Bit   2 HOST_ERROR (not supported by MDD 100)(additional Information to the Host Communication Error in [I-STATUS])&#13;&#10;Bit   3 SHORT_ERROR (short of the power stage)&#13;&#10;Bit   4 RAM_ERROR (error in the code ram area)&#13;&#10;Bit   5 FPGA_WATCHDOG_ERROR (not supported by MDD 100)(is set by the fpga watchdog mechanism)&#13;&#10;Bit   6 ADOFF_ERROR (not supported by MDD 100)(the offset of the motor current is to high)&#13;&#10;Bit   7 VCC18_ERROR (Phasing Direction Error, set when the motor turns in the wrong direction after commutation)&#13;&#10;Bit   8 VCCE_ERROR (Internal Encoder Error)&#13;&#10;Bit   9 ASMFU_IMAX_ERROR (is set if the asynchronous motor current is to high)&#13;&#10;Bit  10 PHASING_SIGNAL_STRENGTH_ERROR (Phasing Signal Strengh Error, more detailed information in Drive help parameter description I-DERROR)&#13;&#10;Bit  11 PHASING_POSITION_ERROR (is set when the position of the motor changes too drastically durin commutation)&#13;&#10;Bit  12 REGEN_ERROR (is set if the regen resistor can not be turned off)&#13;&#10;Bit  13 ENCODER_COUNTER_ERROR (not supported by MDD 100)(is set if the encoder counter check detects a fault)&#13;&#10;Bit  14 SIN_COS_COMMUT_ERROR (is set if a communication error exceeds 50ms)&#13;&#10;Bit  15 LVDS_ERROR (MDD only, is set if a communication error occurs between master and slave)&#13;&#10;Bit  16 PHASING_PHASE_SHIFT_ERROR (is set when the distance between the maximum positive/negative feedback peaks does not equal 180° +- 8°)&#13;&#10;Bit  17 PHASING_FOURIER_SIGNAL_ERROR (fourier signal cannot be calculated)&#13;&#10;&#13;&#10;DC06x&#13;&#10;=============================================================================================&#13;&#10;Bit   3 SHORT_ERROR (short of the power stage)&#13;&#10;Bit  14 FEEDBACK_ADC (feedback resolver values are not valid)(only DC061)&#13;&#10;Bit  16 SAFETY_ERROR  (safety error)&#13;&#10;Bit  17 SAFETY_WARNING (safety warning) &#13;&#10;Bit  22 Z_IMPULS_ERROR  (the z-impuls did not appeared within the time frame) (only DC062)&#13;&#10;Bit  24 FEEDBACK_SUPPLY (the feedback supply voltage fell below 15V)(only DC062)&#13;&#10;&#13;&#10;&#13;&#10;For more detailed informations, look at the parameter description of I-DERROR (201) in the Drive Help.&#13;&#13;&#10;These bits cause the Drive Error Ramp/Drive Error No Ramp in [I-STATUS]."/>
		<Server Name="I_DERROR2" GUID="{F0B24373-7F1E-4AFC-A650-C2B4FDF3D14F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Para-Nr : 217&#13;&#10;Unit  : [-]&#13;&#10;Description : Internal Drive Errors&#13;&#13;&#10;&#13;&#13;&#10;MDD2000 - Drives &#13;&#10;=============================================================================================&#13;&#10;&#13;&#10;&#13;&#10;For more detailed informations, look at the parameter description of I-DERROR2 (217) in the Drive Help.&#13;&#13;&#10;These bits cause the Drive Error Ramp/Drive Error No Ramp in [I-STATUS]."/>
		<Server Name="I_DERROR3" GUID="{825E0AC2-501D-4D11-80C3-FDB4F68CA1DE}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Para-Nr : 218&#13;&#10;Unit  : [-]&#13;&#10;Description : Internal Drive Errors&#13;&#13;&#10;&#13;&#13;&#10;MDD2000 - Drives &#13;&#10;=============================================================================================&#13;&#10;&#13;&#10;&#13;&#10;For more detailed informations, look at the parameter description of I-DERROR3 (218) in the Drive Help.&#13;&#13;&#10;These bits cause the Drive Error Ramp/Drive Error No Ramp in [I-STATUS]."/>
		<Server Name="I_STATUS" GUID="{4DAAE8F7-3F2C-498D-A061-95177AB3C035}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Para-Nr : 199&#13;&#10;Unit  : [-]&#13;&#10;Description : Status register:&#13;&#13;&#10;&#13;&#13;&#10;Bit  1   Mains phase (1-phase supply)&#13;&#10;Bit  2   Mains fault&#13;&#10;Bit  3   Motor axis over-current&#13;&#10;Bit  4   Over voltage DC-Link&#13;&#10;Bit  5   Under voltage DC-link&#13;&#10;Bit  6   Motor axis phase failure&#13;&#10;Bit  7   Holding brake error&#13;&#10;Bit  8   Holding brake switch damaged&#13;&#10;Bit  9   reserved&#13;&#10;Bit  10   Motor thermostat&#13;&#10;Bit 11  Ambient temperature&#13;&#10;Bit 12  Heat sink temperature&#13;&#10;Bit 13  Feedback Error&#13;&#10;Bit 14  Commutation error&#13;&#10;Bit 15  Over speed&#13;&#10;Bit 16  Contouring Error&#13;&#10;Bit 17  Trajectory Error&#13;&#10;Bit 18  Host Communication Error&#13;&#10;Bit 19  Drive Error Ramp, for additional information see [I-DERROR]&#13;&#10;Bit 20  Drive Error No Ramp, for additional information see [I-DERROR]&#13;&#10;Bit 21  External Enable Locked Error&#13;&#10;Bit 22  IGBT Driver Voltage Error&#13;&#10;Bit 23  max. Regen Power Error&#13;&#10;Bit 24  24V Brake Supply Error&#13;&#10;Bit 25  reserved&#13;&#10;Bit 26  I2T-Error&#13;&#10;Bit 27  Motor Temperature Warning&#13;&#10;Bit 28  Motor Parameter Error&#13;&#10;Bit 29  Multi-Turn Position Error&#13;&#10;Bit 30  Max Sum Power Limitation&#13;&#10;Bit 31  Speed Controler in Saturation&#13;&#10;Bit 32  Fan Error &#13;&#10;&#13;&#13;&#10;The masks  [G-MASKE1], [G-MASKE2], [G-MASKW] and [G-MASKD] &#13;&#10;define if the corresponding bit of I-STATUS causes a cast of the motor, a ramp stop of the motor, a warning or nothing.&#13;&#13;&#10;This errors can be cleared with [K-CLRF].&#13;&#10;For more detailed informations, look at the parameter description of I-STATUS(199) in the Drive Help.&#13;&#10;"/>
		<Client Name="Activate_I_DError2" Required="false" Internal="false" DefValue="0" Comment="Get additional Error information from Drive.&#13;&#10;Must be set as Initvalue. Defaultvalue is 0.&#13;&#10;0 .. deactivated&#13;&#10;1 .. activated"/>
		<Client Name="Activate_I_DError3" Required="false" Internal="false" DefValue="0" Comment="Get additional Error information from Drive. &#13;&#10;Must be set as Initvalue. Defaultvalue is 0.&#13;&#10;0 .. deactivated&#13;&#10;1 .. activated"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="HasHan"/>
		<Dokumentation Revision="1.14" Date="18.12.2020" Author="PieSte" Company="Sigmatek" Description="Add  I-DERROR2 and I-DERROR3 parameter  which are activated over clients, for error handling (MDD2000)."/>
		<Dokumentation Revision="1.13" Date="08.11.2016" Author="ZoePat" Company="Sigmatek" Description="Client &quot;DriveAxis&quot; is now not required."/>
		<Dokumentation Revision="1.12" Date="03.11.2015" Author="EisMic" Company="Sigmatek" Description="Bits in server comment now start from 1 instead of 0 to be consistent with the lasal help and the type of the server.."/>
		<Dokumentation Revision="1.11" Date="16.06.2015" Author="EisMic" Company="Sigmatek" Description="Updated description from I-STATUSand I-DERROR Bits."/>
		<Dokumentation Revision="1.10" Date="04.12.2013" Author="ObeChr" Company="Sigmatek" Description="Added missing Bits in Type for Server I-STATUS + I-DERROR"/>
		<Dokumentation Revision="1.1" Date="10.08.2010" Author="Ramand" Company="Sigmatek" Description="For the number of parameters in this group now a constant is used instead of the numerical value for easier change in the future"/>
		<Dokumentation Revision="1.0" Date="05.08.2009" Author="HasHan" Company="Sigmatek" Description="Creation"/>
	</RevDoku>
	<Network Name="_DriveErrorHandling">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{5D924F4A-1ABE-40D2-9865-FF18A3FDFCE0}"
				Class      = "_DriveParaBase"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="State"/>
					<Client Name="DriveAxis"/>
					<Client Name="ErrorCode"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.State" Destination="_base.State" Vertices="(740,210),(568,210),"/>
			<Connection Source="_base.DriveAxis" Destination="this.DriveAxis" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.ErrorCode" Destination="this.ErrorCode" Vertices="(218,270),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _DriveParaBase

_DriveErrorHandling : CLASS
: _DriveParaBase
  //Servers:
	GetErrorInfo 	: SvrCh_DINT;
	I_STATUS 	: SvrCh__SDDISTATE;
	I_DERROR 	: SvrCh__SDDIDERROR;
	I_DERROR2 	: SvrCh_BDINT;
	I_DERROR3 	: SvrCh_BDINT;
  //Clients:
	Activate_I_DError2 	: CltCh_DINT;
	Activate_I_DError3 	: CltCh_DINT;
  //Variables:
		bRdDError2 	: BOOL;
		bRdDError3 	: BOOL;
		dNumberErrorHandling 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL RefreshPara
		VAR_INPUT
			usParaNr 	: USINT;
			dValue 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RefreshAllPara;
	
	FUNCTION GLOBAL GetErrorInformation;
	
	FUNCTION VIRTUAL GLOBAL GetErrorInfo::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _DriveErrorHandling::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__DRIVEERRORHANDLING
1$UINT, 14$UINT, (SIZEOF(::_DriveErrorHandling))$UINT, 
5$UINT, 2$UINT, 0$UINT, 
TO_UDINT(3110367410), "_DriveErrorHandling", //Class
TO_UDINT(3299882984), "_DriveParaBase", 1$UINT, 2$UINT, //Baseclass
//Servers:
(::_DriveErrorHandling.GetErrorInfo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2131191311), "GetErrorInfo", 
(::_DriveErrorHandling.I_STATUS.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3159858376), "I_STATUS", 
(::_DriveErrorHandling.I_DERROR.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2114936407), "I_DERROR", 
(::_DriveErrorHandling.I_DERROR2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4020532484), "I_DERROR2", 
(::_DriveErrorHandling.I_DERROR3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2560837010), "I_DERROR3", 
//Clients:
(::_DriveErrorHandling.Activate_I_DError2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4210786297), "Activate_I_DError2", 
(::_DriveErrorHandling.Activate_I_DError3.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2382122863), "Activate_I_DError3", 
END_FUNCTION


#define USER_CNT__DriveErrorHandling 4

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__DriveErrorHandling] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _DriveErrorHandling::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _DriveParaBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _DriveParaBase::State.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _DriveParaBase::State.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__DriveErrorHandling;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #RefreshPara();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #RefreshAllPara();

#pragma warning (default : 74)
	_DriveParaBase::State.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _DriveParaBase::State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	GetErrorInfo.pMeth			:= StoreMethod( #M_RD_DIRECT(), #GetErrorInfo::Write() );
	IF GetErrorInfo.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL _DriveErrorHandling::Init

  if (IsAxisConnected() = TRUE) then
    DriveAxis.AddParaObjects(Index:=IDX_ERRORHANDLING, pThis:=this); // add the object in the list of the axis
    DriveAxis := ERROR;
    State := DriveAxis.CmdState;
    Activate_I_DError2 := Activate_I_DError2.Read();
    Activate_I_DError3 := Activate_I_DError3.Read();
    bRdDError2 := Activate_I_DError2 <> 0;
    bRdDError3 := Activate_I_DError3 <> 0;
    
    dNumberErrorHandling := NBR_ERRORHANDLING;
    
    //add to errorhandling if activated
    if bRdDError2 then
      dNumberErrorHandling += 1;  
    end_if;
    
    //add to errorhandling if activated
    if bRdDError3 then
      dNumberErrorHandling += 1;  
    end_if;
    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _DriveErrorHandling::GetErrorInfo::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	GetErrorInfo := input;
 	result := GetErrorInfo;
  GetErrorInformation();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _DriveErrorHandling::RefreshPara
	VAR_INPUT
		usParaNr 	: USINT;
		dValue 	: DINT;
	END_VAR

  case usParaNr of
  
    SDD_I_STATUS :
      I_STATUS$DINT := dValue;
      
    SDD_I_DERROR :
      I_DERROR$DINT := dValue;
      
    SDD_I_DERROR2 :
      I_DERROR2$DINT := dValue;
      
    SDD_I_DERROR3 :
      I_DERROR3$DINT := dValue;
    
  end_case;

END_FUNCTION


FUNCTION GLOBAL _DriveErrorHandling::GetErrorInformation
      
  SetASyncCmd(ParaNr:= SDD_I_STATUS, ParaRdWr:= 0, ParaValue:= 0, pThis:= this);
  SetASyncCmd(ParaNr:= SDD_I_DERROR, ParaRdWr:= 0, ParaValue:= 0, pThis:= this);
  
  if bRdDError2 then
    SetASyncCmd(ParaNr:= SDD_I_DERROR2, ParaRdWr:= 0, ParaValue:= 0, pThis:= this);  
  end_if;
  
  if bRdDError3 then
    SetASyncCmd(ParaNr:= SDD_I_DERROR3, ParaRdWr:= 0, ParaValue:= 0, pThis:= this);  
  end_if;
      
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _DriveErrorHandling::RefreshAllPara

  // number of Parameters in this group
  AnzASyncPara += dNumberErrorHandling;

END_FUNCTION
